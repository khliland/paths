<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Path Effects</title>
    <script src="https://cdn.jsdelivr.net/npm/plotly.js@2.26.0/dist/plotly.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 { text-align: center; color: #333; margin-bottom: 20px; }
        .heading-landscape { width: 1040px; display: none; }
        .heading-portrait { width: 90vw; display: none; }
        
        /* Landscape container: controls | plot | right-pane */
        .main-container-landscape { display: grid; grid-template-columns: 280px auto 200px; gap: 15px; justify-content: start; }
        
        /* Portrait container: plot, controls, right-pane (vertical stack with plot spanning) */
        .main-container-portrait { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: auto auto auto; gap: 15px; justify-items: center; }
        .main-container-portrait .plot-container { grid-column: 1 / -1; grid-row: 1; width: 90vw; max-width: 400px; height: auto; aspect-ratio: 1; }
        .main-container-portrait .controls { grid-column: 1; grid-row: 2; width: 90vw; max-width: 250px; }
        .main-container-portrait .right-pane { grid-column: 2; grid-row: 2; width: 90vw; max-width: 250px; }
        
        /* Show/hide based on orientation */
        @media (orientation: landscape) {
            .main-container-landscape { display: grid; }
            .main-container-portrait { display: none; }
            .heading-landscape { display: block; }
            .heading-portrait { display: none; }
        }
        
        @media (orientation: portrait) {
            .main-container-landscape { display: none; }
            .main-container-portrait { display: grid; }
            .main-container-portrait .plot-container { width: 90vw; max-width: 90vw; height: auto; aspect-ratio: 1; }
            .heading-landscape { display: none; }
            .heading-portrait { display: block; }
        }
        .controls { background: white; padding: 15px; border-radius: 8px; height: fit-content; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: normal; font-size: 13px; }
        input[type="range"] { width: 100%; margin: 5px 0; height: 6px; -webkit-appearance: none; appearance: none; background: rgba(0, 137, 123, 0.3); border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00897b; cursor: pointer; box-shadow: 0 2px 5px rgba(0,137,123,0.3); }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00897b; cursor: pointer; border: none; box-shadow: 0 2px 5px rgba(0,137,123,0.3); }
        input[type="range"]::-moz-range-track { background: transparent; border: none; }
        input[type="checkbox"] { margin-right: 8px; }
        .slider-value { font-size: 12px; color: #666; margin-left: 10px; }
        .checkbox-label { display: flex; align-items: center; margin-bottom: 8px; font-weight: normal; }
        .expander { margin-top: 10px; margin-bottom: 15px; border-left: 3px solid #00897b; }
        .expander-header { background: #f9f9f9; padding: 10px; cursor: pointer; user-select: none; display: flex; align-items: center; font-size: 13px; font-weight: 500; }
        .expander-header:hover { background: #f0f0f0; }
        .expander-toggle { display: inline-block; margin-right: 8px; width: 16px; text-align: center; }
        .expander-content { display: none; padding: 10px; background: #fafafa; font-size: 12px; line-height: 1.5; color: #555; }
        .expander-content.open { display: block; }
        .plot-container { background: white; padding: 15px; border-radius: 8px; width: 545px; height: 545px; }
        #plot { width: 100%; height: 100%; }
        .stats { background: white; padding: 12px; border-radius: 8px; font-size: 12px; }
        .stats h3 { margin: 0 0 10px 0; font-size: 14px; }
        .stat-item { margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #eee; display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; }
        .stat-item:last-child { border-bottom: none; }
        .stat-label { font-size: 14px; color: #666; cursor: help; position: relative; }
        .stat-value { font-size: 14px; font-weight: bold; color: #333; text-align: right; cursor: help; position: relative; }
        .stat-item:hover .stat-label::after { content: attr(data-tooltip); position: absolute; bottom: 125%; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 6px 10px; border-radius: 4px; white-space: nowrap; font-size: 12px; z-index: 1000; pointer-events: none; }
        .stat-item:hover .stat-label::before { content: ''; position: absolute; bottom: 120%; left: 50%; transform: translateX(-50%); border: 5px solid transparent; border-top-color: #333; z-index: 1000; pointer-events: none; }
        .stat-label.touch-active::after { content: attr(data-tooltip); position: absolute; bottom: 125%; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 6px 10px; border-radius: 4px; white-space: nowrap; font-size: 12px; z-index: 1000; pointer-events: none; }
        .stat-label.touch-active::before { content: ''; position: absolute; bottom: 120%; left: 50%; transform: translateX(-50%); border: 5px solid transparent; border-top-color: #333; z-index: 1000; pointer-events: none; }
        .stat-value { font-size: 14px; font-weight: bold; color: #333; text-align: right; }
        .stat-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-left: 6px; visibility: hidden; flex-shrink: 0; }
        .checkbox-label { cursor: help; position: relative; }
        .checkbox-label:hover::after { content: attr(title); position: absolute; bottom: 125%; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 1000; pointer-events: none; white-space: normal; width: 180px; text-align: center; }
        .checkbox-label:hover::before { content: ''; position: absolute; bottom: 120%; left: 50%; transform: translateX(-50%); border: 5px solid transparent; border-top-color: #333; z-index: 1000; pointer-events: none; }
        .right-pane { display: flex; flex-direction: column; gap: 15px; }
        .diagram { background: white; padding: 12px; border-radius: 8px; text-align: center; cursor: help; position: relative; }
        .diagram:hover::after { content: attr(title); position: absolute; bottom: 125%; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 1000; pointer-events: none; white-space: normal; width: 200px; text-align: center; }
        .diagram:hover::before { content: ''; position: absolute; bottom: 120%; left: 50%; transform: translateX(-50%); border: 5px solid transparent; border-top-color: #333; z-index: 1000; pointer-events: none; }
        .diagram img { width: 100%; max-width: 200px; height: auto; }
        .equations { background: white; padding: 12px; border-radius: 8px; font-size: 14px; line-height: 1.8; cursor: help; position: relative; }
        .equations:hover::after { content: attr(title); position: absolute; bottom: 125%; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 1000; pointer-events: none; white-space: normal; width: 200px; text-align: center; }
        .equations:hover::before { content: ''; position: absolute; bottom: 120%; left: 50%; transform: translateX(-50%); border: 5px solid transparent; border-top-color: #333; z-index: 1000; pointer-events: none; }
        .equations div { margin-bottom: 8px; }
        .loading { text-align: center; padding: 40px; font-size: 18px; }
    </style>
</head>
<body>
    <h1 class="heading-landscape">Path Contributions</h1>
    <h1 class="heading-portrait">Path Contributions</h1>
    <div class="loading" id="loading">Loading...</div>
    <div id="main" style="display: none;">
        <!-- Landscape: Left | Plot | Right -->
        <div class="main-container-landscape" id="landscape-container">
            <div class="controls">
                <div class="control-group">
                    <label>Œ∏<sub>A</sub>: <span class="slider-value" id="val_theta_a">0.50</span></label>
                    <input type="range" id="theta_a" min="-1" max="1" step="0.01" value="0.5">
                </div>
                <div class="control-group">
                    <label>Œ∏<sub>B</sub>: <span class="slider-value" id="val_theta_b">0.40</span></label>
                    <input type="range" id="theta_b" min="-1" max="1" step="0.01" value="0.4">
                </div>
                <div class="control-group">
                    <label>Œ≥: <span class="slider-value" id="val_gamma">0.30</span></label>
                    <input type="range" id="gamma" min="-1" max="1" step="0.01" value="0.3">
                </div>
                <hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">
                <div class="control-group">
                    <label class="checkbox-label" title="See Explanation below when activated">
                        <input type="checkbox" id="regression">
                        Regression
                    </label>
                </div>
                <div class="control-group">
                    <label class="checkbox-label" title="See Explanation below when activated">
                        <input type="checkbox" id="orthProj">
                        Centred Orthogonal Projections
                    </label>
                </div>
                <div class="control-group">
                    <label class="checkbox-label" title="See Explanation below when activated">
                        <input type="checkbox" id="chained">
                        Chained Orthogonal Projections
                    </label>
                </div>
                <div class="control-group">
                    <label class="checkbox-label" title="See Explanation below when activated">
                        <input type="checkbox" id="EVs">
                        Contribution circles
                    </label>
                </div>
                
                <!-- Single Explanation Expander -->
                <div class="expander" id="expander-explanation">
                    <div class="expander-header">
                        <span class="expander-toggle">‚ñ∂</span>
                        <span>Explanation</span>
                    </div>
                    <div class="expander-content" id="explanation-content">
                        Select a visualization option to see its explanation.
                    </div>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot"></div>
            </div>
            
            <div class="right-pane">
                <div class="stats">
                    <h3>Contributions</h3>
                    <div class="stat-item"><div class="stat-label" data-tooltip="Total">T<sub>A‚ÜíC</sub></div><div class="stat-value" id="stat_T">-</div><span class="stat-dot" id="dot_T" style="background-color: black;"></span></div>
                    <div class="stat-item"><div class="stat-label" data-tooltip="Unique">U<sub>A‚ÜíC</sub></div><div class="stat-value" id="stat_U">-</div><span class="stat-dot" id="dot_U" style="background-color: green;"></span></div>
                    <div class="stat-item"><div class="stat-label" data-tooltip="Indirect">Ind<sub>A(B)‚ÜíC</sub></div><div class="stat-value" id="stat_INT">-</div><span class="stat-dot" id="dot_INT" style="background-color: transparent;"></span></div>
                    <div class="stat-item"><div class="stat-label" data-tooltip="Additional">Ad<sub>A(B)‚ÜíC</sub></div><div class="stat-value" id="stat_Ad">-</div><span class="stat-dot" id="dot_Ad" style="background-color: transparent;"></span></div>
                </div>
                <div class="diagram" title="Directed Acyclic Graph relating the three blocks/variables.">
                    <img src="img/DAG.png" alt="Directed Acyclic Graph">
                </div>
                <div class="equations" title="Equations linking the vectors together through coefficients chosen using the sliders.">
                    <div><b style="color: #2ca02c;">x</b><sub style="color: #2ca02c;">C</sub> = <b style="color: #1f77b4;">x</b><sub style="color: #1f77b4;">A</sub> Œ∏<sub>A</sub> + <b style="color: #9467bd;">x</b><sub style="color: #9467bd;">B</sub> Œ∏<sub>B</sub> + <b>e</b></div>
                    <div><b style="color: #9467bd;">x</b><sub style="color: #9467bd;">B</sub> = <b style="color: #1f77b4;">x</b><sub style="color: #1f77b4;">A</sub> Œ≥ + <b>f</b></div>
                </div>
            </div>
        </div>
        
        <!-- Portrait: Plot | Left | Right (stacked) -->
        <div class="main-container-portrait" id="portrait-container">
            <div class="plot-container">
                <div id="plot-portrait"></div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Œ∏<sub>A</sub>: <span class="slider-value" id="val_theta_a_p">0.50</span></label>
                    <input type="range" id="theta_a_p" min="-1" max="1" step="0.01" value="0.5">
                </div>
                <div class="control-group">
                    <label>Œ∏<sub>B</sub>: <span class="slider-value" id="val_theta_b_p">0.40</span></label>
                    <input type="range" id="theta_b_p" min="-1" max="1" step="0.01" value="0.4">
                </div>
                <div class="control-group">
                    <label>Œ≥: <span class="slider-value" id="val_gamma_p">0.30</span></label>
                    <input type="range" id="gamma_p" min="-1" max="1" step="0.01" value="0.3">
                </div>
                <hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">
                <div class="control-group">
                    <label class="checkbox-label" title="See Explanation below when activated">
                        <input type="checkbox" id="regression_p">
                        Regression
                    </label>
                </div>
                <div class="control-group">
                    <label class="checkbox-label" title="See Explanation below when activated">
                        <input type="checkbox" id="orthProj_p">
                        Centred Orthogonal Projections
                    </label>
                </div>
                <div class="control-group">
                    <label class="checkbox-label" title="See Explanation below when activated">
                        <input type="checkbox" id="chained_p">
                        Chained Orthogonal Projections
                    </label>
                </div>
                <div class="control-group">
                    <label class="checkbox-label" title="See Explanation below when activated">
                        <input type="checkbox" id="EVs_p">
                        Contribution circles
                    </label>
                </div>
                
                <!-- Single Explanation Expander (portrait) -->
                <div class="expander" id="expander-explanation_p">
                    <div class="expander-header">
                        <span class="expander-toggle">‚ñ∂</span>
                        <span>Explanation</span>
                    </div>
                    <div class="expander-content" id="explanation-content_p">
                        Select a visualization option to see its explanation.
                    </div>
                </div>
            </div>
            
            <div class="right-pane">
                <div class="stats">
                    <h3>Contributions</h3>
                    <div class="stat-item"><div class="stat-label" data-tooltip="Total">T<sub>A‚ÜíC</sub></div><div class="stat-value" id="stat_T_p">-</div><span class="stat-dot" id="dot_T_p" style="background-color: black;"></span></div>
                    <div class="stat-item"><div class="stat-label" data-tooltip="Unique">U<sub>A‚ÜíC</sub></div><div class="stat-value" id="stat_U_p">-</div><span class="stat-dot" id="dot_U_p" style="background-color: green;"></span></div>
                    <div class="stat-item"><div class="stat-label" data-tooltip="Indirect">Ind<sub>A(B)‚ÜíC</sub></div><div class="stat-value" id="stat_INT_p">-</div><span class="stat-dot" id="dot_INT_p" style="background-color: transparent;"></span></div>
                    <div class="stat-item"><div class="stat-label" data-tooltip="Additional">Ad<sub>A(B)‚ÜíC</sub></div><div class="stat-value" id="stat_Ad_p">-</div><span class="stat-dot" id="dot_Ad_p" style="background-color: transparent;"></span></div>
                </div>
                <div class="diagram" title="Directed Acyclic Graph relating the three blocks/variables.">
                    <img src="img/DAG.png" alt="Directed Acyclic Graph">
                </div>
                <div class="equations" title="Equations linking the vectors together through coefficients chosen using the sliders.">
                    <div><b style="color: #2ca02c;">x</b><sub style="color: #2ca02c;">C</sub> = <b style="color: #1f77b4;">x</b><sub style="color: #1f77b4;">A</sub>Œ∏<sub>A</sub> + <b style="color: #9467bd;">x</b><sub style="color: #9467bd;">B</sub>Œ∏<sub>B</sub> + <b>e</b></div>
                    <div><b style="color: #9467bd;">x</b><sub style="color: #9467bd;">B</sub> = <b style="color: #1f77b4;">x</b><sub style="color: #1f77b4;">A</sub>Œ≥ + <b>f</b></div>
                </div>
            </div>
        </div>
    </div>
    </div>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.0/full/pyodide.js"></script>
    <script>
        let pyodide = null;
        let lastValidState = { theta_a: 0.5, theta_b: 0.4, gamma: 0.3 };

        // Sync both containers to keep them in sync
        function syncContainers() {
            document.getElementById("theta_a_p").value = document.getElementById("theta_a").value;
            document.getElementById("theta_b_p").value = document.getElementById("theta_b").value;
            document.getElementById("gamma_p").value = document.getElementById("gamma").value;
            
            document.getElementById("regression_p").checked = document.getElementById("regression").checked;
            document.getElementById("orthProj_p").checked = document.getElementById("orthProj").checked;
            document.getElementById("chained_p").checked = document.getElementById("chained").checked;
            document.getElementById("EVs_p").checked = document.getElementById("EVs").checked;
            
            // Also sync the display values
            document.getElementById("val_theta_a_p").textContent = document.getElementById("val_theta_a").textContent;
            document.getElementById("val_theta_b_p").textContent = document.getElementById("val_theta_b").textContent;
            document.getElementById("val_gamma_p").textContent = document.getElementById("val_gamma").textContent;
            
            // Also sync expander states
            syncExpanderStates();
        }

        function syncExpanderStates() {
            const landscapeExpander = document.getElementById('expander-explanation');
            const portraitExpander = document.getElementById('expander-explanation_p');
            
            if (landscapeExpander && portraitExpander) {
                const landscapeContent = landscapeExpander.querySelector('.expander-content');
                const portraitContent = portraitExpander.querySelector('.expander-content');
                
                if (landscapeContent && landscapeContent.classList.contains('open')) {
                    portraitContent.classList.add('open');
                    portraitExpander.querySelector('.expander-toggle').textContent = '‚ñº';
                } else if (portraitContent) {
                    portraitContent.classList.remove('open');
                    portraitExpander.querySelector('.expander-toggle').textContent = '‚ñ∂';
                }
            }
        }

        function updateExplanation() {
            const regression = document.getElementById("regression").checked;
            const orthProj = document.getElementById("orthProj").checked;
            const chained = document.getElementById("chained").checked;
            const EVs = document.getElementById("EVs").checked;
            
            let explanation = "";
            
            if (!regression && !orthProj && !chained && !EVs) {
                explanation = "Select a visualization option to see its explanation.";
            } else {
                const parts = [];
                
                if (regression) {
                    parts.push("üîµ <b>Regression</b>: Shows how X<sub>C</sub> is explained by X<sub>A</sub> (blue) and X<sub>B</sub> (purple).");
                }
                
                if (orthProj) {
                    parts.push("üìê <b>Centred Orthogonal Projections</b>: Decomposes regression vectors into orthogonal and projected components, showing independent and correlated contributions.");
                    if (regression) {
                        parts.push("üîó <i>Combined with Regression</i>: Gray dotted connector lines link each decomposition to its regression endpoint, revealing the relationships between the two methods.");
                    }
                }
                
                if (chained) {
                    parts.push("‚õìÔ∏è <b>Chained Orthogonal Projections</b>: Like the centred version, but shows cumulative effect path starting with X<sub>A</sub> orthogonal to X<sub>B</sub>, then X<sub>A</sub> projected on X<sub>B</sub>, then the X<sub>B</sub> effects in sequence.");
                }
                
                if (EVs) {
                    parts.push("‚≠ï <b>Contribution circles</b>: Displays circles for variance explained (T and U contributions) with contribution dots on respective vectors.");
                }
                
                explanation = parts.join("<br><br>");
            }
            
            // Update both landscape and portrait
            const contentElement = document.getElementById("explanation-content");
            const contentElement_p = document.getElementById("explanation-content_p");
            
            if (contentElement) contentElement.innerHTML = explanation;
            if (contentElement_p) contentElement_p.innerHTML = explanation;
        }

        function setupExpanderListeners() {
            const expanderIds = ['explanation'];
            
            for (const id of expanderIds) {
                for (const suffix of ['', '_p']) {
                    const expanderId = 'expander-' + id + suffix;
                    const expander = document.getElementById(expanderId);
                    if (expander) {
                        const header = expander.querySelector('.expander-header');
                        header.addEventListener('click', (e) => {
                            e.preventDefault();
                            const content = expander.querySelector('.expander-content');
                            const toggle = expander.querySelector('.expander-toggle');
                            
                            content.classList.toggle('open');
                            toggle.textContent = content.classList.contains('open') ? '‚ñº' : '‚ñ∂';
                            
                            // Sync to the other orientation
                            const otherSuffix = suffix === '' ? '_p' : '';
                            const otherExpanderId = 'expander-' + id + otherSuffix;
                            const otherExpander = document.getElementById(otherExpanderId);
                            if (otherExpander) {
                                const otherContent = otherExpander.querySelector('.expander-content');
                                const otherToggle = otherExpander.querySelector('.expander-toggle');
                                if (content.classList.contains('open')) {
                                    otherContent.classList.add('open');
                                    otherToggle.textContent = '‚ñº';
                                } else {
                                    otherContent.classList.remove('open');
                                    otherToggle.textContent = '‚ñ∂';
                                }
                            }
                        });
                    }
                }
            }
        }

        function setupTouchTooltips() {
            const labels = document.querySelectorAll('.stat-label');
            const values = document.querySelectorAll('.stat-value');
            
            const toggleTooltip = (label) => {
                e.preventDefault();
                
                // Remove active class from all labels
                document.querySelectorAll('.stat-label').forEach(l => {
                    l.classList.remove('touch-active');
                });
                
                // Add active class to clicked label
                label.classList.add('touch-active');
            };
            
            // Handle label touches
            labels.forEach(label => {
                label.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    
                    // Remove active class from all labels
                    document.querySelectorAll('.stat-label').forEach(l => {
                        l.classList.remove('touch-active');
                    });
                    
                    // Add active class to clicked label
                    label.classList.add('touch-active');
                });
            });
            
            // Handle value touches - find and activate the corresponding label
            values.forEach(value => {
                value.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    
                    // Find the sibling label and activate its tooltip
                    const statItem = value.closest('.stat-item');
                    if (statItem) {
                        const label = statItem.querySelector('.stat-label');
                        
                        // Remove active class from all labels
                        document.querySelectorAll('.stat-label').forEach(l => {
                            l.classList.remove('touch-active');
                        });
                        
                        // Add active class to the corresponding label
                        if (label) {
                            label.classList.add('touch-active');
                        }
                    }
                });
            });
            
            // Remove tooltip when clicking elsewhere
            document.addEventListener('touchstart', (e) => {
                if (!e.target.classList.contains('stat-label')) {
                    document.querySelectorAll('.stat-label').forEach(l => {
                        l.classList.remove('touch-active');
                    });
                }
            });
        }

        function isValidPlot() {
            // Check if any statistics value is NaN
            const stats = ['stat_T', 'stat_U', 'stat_INT', 'stat_Ad'];
            for (const statId of stats) {
                const text = document.getElementById(statId).textContent;
                if (text.includes('NaN') || text === '-') {
                    return false;
                }
            }
            return true;
        }

        function saveValidState() {
            lastValidState = {
                theta_a: parseFloat(document.getElementById("theta_a").value),
                theta_b: parseFloat(document.getElementById("theta_b").value),
                gamma: parseFloat(document.getElementById("gamma").value)
            };
        }

        function revertToLastValid() {
            document.getElementById("theta_a").value = lastValidState.theta_a;
            document.getElementById("theta_b").value = lastValidState.theta_b;
            document.getElementById("gamma").value = lastValidState.gamma;
            updatePlot();
        }

        function findValidValue(sliderId) {
            const slider = document.getElementById(sliderId);
            const currentValue = parseFloat(slider.value);
            
            // Normalize portrait ID to landscape ID for looking up lastValidState
            const normalizedId = sliderId.endsWith('_p') ? sliderId.slice(0, -2) : sliderId;
            const lastValidValue = lastValidState[normalizedId];
            
            // Binary search between lastValidValue and currentValue
            let low, high;
            if (currentValue > lastValidValue) {
                low = lastValidValue;
                high = currentValue;
            } else {
                low = currentValue;
                high = lastValidValue;
            }
            
            // Binary search for the boundary
            let validValue = lastValidValue;
            
            // Iterate until we narrow down to acceptable precision
            for (let i = 0; i < 30; i++) {
                const mid = (low + high) / 2;
                slider.value = mid;
                // Sync portrait slider to landscape if adjusting landscape slider
                if (!sliderId.endsWith('_p')) {
                    const portraitId = sliderId + '_p';
                    const portraitSlider = document.getElementById(portraitId);
                    if (portraitSlider) portraitSlider.value = mid;
                } else {
                    // Sync landscape slider to portrait if adjusting portrait slider
                    const landscapeId = sliderId.slice(0, -2);
                    const landscapeSlider = document.getElementById(landscapeId);
                    if (landscapeSlider) landscapeSlider.value = mid;
                }
                updatePlot();
                
                if (isValidPlot()) {
                    validValue = mid;
                    // Move towards the direction we were going
                    if (currentValue > lastValidValue) {
                        low = mid;
                    } else {
                        high = mid;
                    }
                } else {
                    // Move away from this invalid point
                    if (currentValue > lastValidValue) {
                        high = mid;
                    } else {
                        low = mid;
                    }
                }
                
                // Stop when precision is good enough (0.01 step)
                if (Math.abs(high - low) < 0.005) {
                    break;
                }
            }
            
            // Set to the valid value found
            slider.value = validValue;
            // Sync the other slider too
            if (!sliderId.endsWith('_p')) {
                const portraitId = sliderId + '_p';
                const portraitSlider = document.getElementById(portraitId);
                if (portraitSlider) portraitSlider.value = validValue;
            } else {
                const landscapeId = sliderId.slice(0, -2);
                const landscapeSlider = document.getElementById(landscapeId);
                if (landscapeSlider) landscapeSlider.value = validValue;
            }
            updatePlot();
            saveValidState();
        }

        async function initPython() {
            try {
                console.log("Starting Pyodide initialization...");
                pyodide = await loadPyodide();
                console.log("Pyodide loaded successfully");
                
                console.log("Loading NumPy...");
                await pyodide.loadPackage("numpy");
                console.log("NumPy loaded successfully");

                const pythonCode = `
import numpy as np

def generate_data(n, theta_a, theta_b, gamma):
    np.random.seed(42)
    X = np.random.randn(n, 4)
    U, _, _ = np.linalg.svd(X - X.mean(axis=0), full_matrices=False)
    xa = U[:, 0] / np.std(U[:, 0])
    f = U[:, 1] / np.std(U[:, 1])
    e = U[:, 2] / np.std(U[:, 2])
    std_xa_gamma = np.std(xa * gamma)
    std_f = np.sqrt(1 - std_xa_gamma**2)
    xb = xa * gamma + f * std_f
    std_xa_theta_a_xb_theta_b = np.std(xa * theta_a + xb * theta_b)
    std_e = np.sqrt(1 - std_xa_theta_a_xb_theta_b**2)
    xc = xa * theta_a + xb * theta_b + e * std_e
    return xa, xb, xc, e * std_e

def proj(y, x):
    # Handle 1D arrays by converting to column vectors
    if len(x.shape) == 1:
        x = x.reshape(-1, 1)
    if len(y.shape) == 1:
        y = y.reshape(-1, 1)
    # Now compute: x @ inv(x.T @ x) @ x.T @ y
    XtX_inv = np.linalg.inv(x.T @ x)
    result = x @ XtX_inv @ x.T @ y
    # Return as 1D if input was 1D
    return result.flatten()

def orth(y, x):
    # Handle 1D arrays by converting to column vectors
    if len(x.shape) == 1:
        x = x.reshape(-1, 1)
    if len(y.shape) == 1:
        y = y.reshape(-1, 1)
    # Now compute: y - x @ inv(x.T @ x) @ x.T @ y
    XtX_inv = np.linalg.inv(x.T @ x)
    result = y - x @ XtX_inv @ x.T @ y
    # Return as 1D if input was 1D
    return result.flatten()

def plot_arrows_data(theta_a=0.5, theta_b=0.4, gamma=0.3, regression=False, orthProj=False, chained=False, EVs=False):
    N = 10
    xa, xb, xc, e = generate_data(N, theta_a, theta_b, gamma)
    
    xa_orth_xb = orth(xa, xb) * theta_a
    xa_proj_xb = proj(xa, xb) * theta_a
    xb_orth_xa = orth(xb, xa) * theta_b
    xb_proj_xa = proj(xb, xa) * theta_b
    xc_hat = xa * theta_a + xb * theta_b
    
    C_EV = np.sum(xc**2)
    U_EV = np.sum(xa_orth_xb**2) / C_EV
    V_EV = np.sum(xa_proj_xb**2) / C_EV
    D_EV = np.sum((xa_orth_xb + xa_proj_xb)**2) / C_EV
    T_EV = np.sum((xa_orth_xb + xa_proj_xb + xb_proj_xa)**2) / C_EV
    A_EV = np.sum(xb_orth_xa**2) / C_EV
    C_hat_EV = np.sum(xc_hat**2) / C_EV
    
    angle = np.arccos(np.clip(np.dot(xa, xb) / (np.linalg.norm(xa) * np.linalg.norm(xb)), -1.0, 1.0))
    anglec = np.arccos(np.clip(np.dot(xa, xc_hat) / (np.linalg.norm(xa) * np.linalg.norm(xc_hat)), -1.0, 1.0))
    angle_aorthb = np.arccos(np.clip(np.dot(xa, xa_orth_xb) / (np.linalg.norm(xa) * np.linalg.norm(xa_orth_xb)), -1.0, 1.0))
    angle_aprojb = np.arccos(np.clip(np.dot(xa, xa_proj_xb) / (np.linalg.norm(xa) * np.linalg.norm(xa_proj_xb)), -1.0, 1.0))
    angle_bortha = np.arccos(np.clip(np.dot(xa, xb_orth_xa) / (np.linalg.norm(xa) * np.linalg.norm(xb_orth_xa)), -1.0, 1.0))
    angle_bproja = 0
    
    sig1 = 1 if theta_b > 0 else -1
    sig2 = -1 if gamma > 0 else 1
    sig3 = 1 if theta_a > 0 else -1
    
    # Cap the xc_hat length to max 2.0 to keep it visible on the plot
    xc_hat_length = np.sqrt(C_hat_EV)
    xc_hat_length = min(xc_hat_length, 2.0)
    
    arrows = []
    arrows.append({'x': [0.0, 1.0], 'y': [0.0, 0.0], 'color': 'blue', 'name': '<b>x</b><sub>A</sub>', 'width': 3, 'hovertemplate': '<b>x</b><sub>A</sub><br>x: %{x:.2f}<br>y: %{y:.2f}<extra></extra>'})
    arrows.append({'x': [0.0, float(np.cos(angle))], 'y': [0.0, float(np.sin(angle))], 'color': 'purple', 'name': '<b>x</b><sub>B</sub>', 'width': 3, 'hovertemplate': '<b>x</b><sub>B</sub><br>x: %{x:.2f}<br>y: %{y:.2f}<extra></extra>'})
    arrows.append({'x': [0.0, float(np.cos(sig1 * anglec) * xc_hat_length)], 'y': [0.0, float(np.sin(sig1 * anglec) * xc_hat_length)], 'color': 'green', 'name': '<b>x&#770;</b><sub>C</sub>', 'width': 3, 'hovertemplate': '<b>xÃÇ</b><sub>C</sub><br>x: %{x:.2f}<br>y: %{y:.2f}<extra></extra>'})
    
    if regression:
        arrows.append({'x': [0.0, float(theta_a)], 'y': [0.0, 0.0], 'color': 'blue', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [0.0, float(np.cos(angle) * theta_b)], 'y': [0.0, float(np.sin(angle) * theta_b)], 'color': 'purple', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [float(np.cos(angle) * theta_b), float(np.cos(angle) * theta_b + theta_a)], 'y': [float(np.sin(angle) * theta_b), float(np.sin(angle) * theta_b)], 'color': 'blue', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [float(theta_a), float(theta_a + np.cos(angle) * theta_b)], 'y': [0.0, float(np.sin(angle) * theta_b)], 'color': 'purple', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
    
    if orthProj:
        norm_xa_theta_a = np.sqrt(np.sum((xa * theta_a)**2))
        norm_xb_theta_b = np.sqrt(np.sum((xb * theta_b)**2))
        
        xa_orth_scale = np.sqrt(np.sum(xa_orth_xb**2)) / norm_xa_theta_a
        xa_proj_scale = np.sqrt(np.sum(xa_proj_xb**2)) / norm_xa_theta_a
        xb_proj_scale = np.sqrt(np.sum(xb_proj_xa**2)) / norm_xb_theta_b
        xb_orth_scale = np.sqrt(np.sum(xb_orth_xa**2)) / norm_xb_theta_b
        
        xa_orth_endpoint = [float(sig3 * np.cos(sig2 * angle_aorthb) * xa_orth_scale * theta_a), float(np.sin(sig2 * angle_aorthb) * xa_orth_scale * theta_a)]
        xa_proj_endpoint = [float(sig3 * np.cos(-sig2 * angle_aprojb) * xa_proj_scale * theta_a), float(np.sin(-sig2 * angle_aprojb) * xa_proj_scale * theta_a)]
        xb_proj_endpoint = [float(-sig2 * np.cos(angle_bproja) * xb_proj_scale * theta_b), 0.0]
        xb_orth_endpoint = [float(sig3 * np.cos(angle_bortha) * xb_orth_scale * theta_b), float(np.sin(angle_bortha) * xb_orth_scale * theta_b)]
        
        arrows.append({'x': [0.0, xa_orth_endpoint[0]], 'y': [0.0, xa_orth_endpoint[1]], 'color': 'blue', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [0.0, xa_proj_endpoint[0]], 'y': [0.0, xa_proj_endpoint[1]], 'color': 'blue', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [0.0, xb_proj_endpoint[0]], 'y': [0.0, xb_proj_endpoint[1]], 'color': 'purple', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [0.0, xb_orth_endpoint[0]], 'y': [0.0, xb_orth_endpoint[1]], 'color': 'purple', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        
        # Add connectors if both regression and orthProj are enabled
        if regression:
            reg_blue_endpoint = [float(theta_a), 0.0]
            reg_purple_endpoint = [float(np.cos(angle) * theta_b), float(np.sin(angle) * theta_b)]
            
            # Connect regression blue to orthogonal blue components
            arrows.append({'x': [reg_blue_endpoint[0], xa_orth_endpoint[0]], 'y': [reg_blue_endpoint[1], xa_orth_endpoint[1]], 'color': 'gray', 'name': '', 'width': 1.0, 'dash': 'dot', 'opacity': 0.5})
            arrows.append({'x': [reg_blue_endpoint[0], xa_proj_endpoint[0]], 'y': [reg_blue_endpoint[1], xa_proj_endpoint[1]], 'color': 'gray', 'name': '', 'width': 1.0, 'dash': 'dot', 'opacity': 0.5})
            
            # Connect blue regression (at origin) to orthogonal purple components
            arrows.append({'x': [reg_purple_endpoint[0], xb_proj_endpoint[0]], 'y': [reg_purple_endpoint[1], xb_proj_endpoint[1]], 'color': 'gray', 'name': '', 'width': 1.0, 'dash': 'dot', 'opacity': 0.5})
            arrows.append({'x': [reg_purple_endpoint[0], xb_orth_endpoint[0]], 'y': [reg_purple_endpoint[1], xb_orth_endpoint[1]], 'color': 'gray', 'name': '', 'width': 1.0, 'dash': 'dot', 'opacity': 0.5})
    
    if chained:
        norm_xa_theta_a = np.sqrt(np.sum((xa * theta_a)**2))
        norm_xb_theta_b = np.sqrt(np.sum((xb * theta_b)**2))
        
        xa_orth_scale = np.sqrt(np.sum(xa_orth_xb**2)) / norm_xa_theta_a
        xa_proj_scale = np.sqrt(np.sum(xa_proj_xb**2)) / norm_xa_theta_a
        xb_proj_scale = np.sqrt(np.sum(xb_proj_xa**2)) / norm_xb_theta_b
        xb_orth_scale = np.sqrt(np.sum(xb_orth_xa**2)) / norm_xb_theta_b
        
        x1 = sig3 * np.cos(sig2 * angle_aorthb) * xa_orth_scale * theta_a
        y1 = np.sin(sig2 * angle_aorthb) * xa_orth_scale * theta_a
        x2 = sig3 * np.cos(-sig2 * angle_aprojb) * xa_proj_scale * theta_a
        y2 = np.sin(-sig2 * angle_aprojb) * xa_proj_scale * theta_a
        x3 = -sig2 * np.cos(angle_bproja) * xb_proj_scale * theta_b
        y3 = 0.0
        x4 = sig3 * np.cos(angle_bortha) * xb_orth_scale * theta_b
        y4 = np.sin(angle_bortha) * xb_orth_scale * theta_b
        
        arrows.append({'x': [0.0, float(x1)], 'y': [0.0, float(y1)], 'color': 'blue', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [float(x1), float(x1 + x2)], 'y': [float(y1), float(y1 + y2)], 'color': 'blue', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [float(x1 + x2), float(x1 + x2 + x3)], 'y': [float(y1 + y2), float(y1 + y2 + y3)], 'color': 'purple', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
        arrows.append({'x': [float(x1 + x2 + x3), float(x1 + x2 + x3 + x4)], 'y': [float(y1 + y2 + y3), float(y1 + y2 + y3 + y4)], 'color': 'purple', 'name': '', 'width': 1.5, 'dash': 'dash', 'opacity': 0.3})
    
    if EVs:
        x1 = sig3 * np.cos(sig2 * angle_aorthb) * np.sqrt(np.sum(xa_orth_xb**2) / np.sum((xa * theta_a)**2)) * theta_a
        y1 = np.sin(sig2 * angle_aorthb) * np.sqrt(np.sum(xa_orth_xb**2) / np.sum((xa * theta_a)**2)) * theta_a
        x_chain = sig3 * np.cos(sig2 * angle_aorthb) * np.sqrt(np.sum(xa_orth_xb**2) / np.sum((xa * theta_a)**2)) * theta_a + sig3 * np.cos(-sig2 * angle_aprojb) * np.sqrt(np.sum(xa_proj_xb**2) / np.sum((xa * theta_a)**2)) * theta_a - sig2 * np.cos(angle_bproja) * np.sqrt(np.sum(xb_proj_xa**2) / np.sum((xb * theta_b)**2)) * theta_b
        y_chain = np.sin(sig2 * angle_aorthb) * np.sqrt(np.sum(xa_orth_xb**2) / np.sum((xa * theta_a)**2)) * theta_a + np.sin(-sig2 * angle_aprojb) * np.sqrt(np.sum(xa_proj_xb**2) / np.sum((xa * theta_a)**2)) * theta_a
    
    contributions = {'circles': [], 'dots': []}
    if EVs:
        # Circle for U_EV
        contributions['circles'].append({'center': [0.0, 0.0], 'radius': float(np.sqrt(U_EV)), 'color': 'green', 'label': 'U'})
        contributions['dots'].append({'x': float(x1), 'y': float(y1), 'color': 'green', 'label': 'U'})
        
        # Circle for T_EV
        contributions['circles'].append({'center': [0.0, 0.0], 'radius': float(np.sqrt(T_EV)), 'color': 'black', 'label': 'T'})
        x_t = sig3 * np.cos(sig2 * angle_aorthb) * np.sqrt(np.sum(xa_orth_xb**2) / np.sum((xa * theta_a)**2)) * theta_a + sig3 * np.cos(-sig2 * angle_aprojb) * np.sqrt(np.sum(xa_proj_xb**2) / np.sum((xa * theta_a)**2)) * theta_a - sig2 * np.cos(angle_bproja) * np.sqrt(np.sum(xb_proj_xa**2) / np.sum((xb * theta_b)**2)) * theta_b
        y_t = np.sin(sig2 * angle_aorthb) * np.sqrt(np.sum(xa_orth_xb**2) / np.sum((xa * theta_a)**2)) * theta_a + np.sin(-sig2 * angle_aprojb) * np.sqrt(np.sum(xa_proj_xb**2) / np.sum((xa * theta_a)**2)) * theta_a
        contributions['dots'].append({'x': float(x_t), 'y': float(y_t), 'color': 'black', 'label': 'T'})
    
    return {'arrows': arrows, 'contributions': contributions, 'T': float(T_EV), 'U': float(U_EV), 'INT': float(T_EV - U_EV), 'Ad': float(A_EV), 'angle_ab': float(angle / np.pi), 'angle_ac': float(np.arccos(np.clip(np.dot(xa, xc) / (np.linalg.norm(xa) * np.linalg.norm(xc)), -1, 1)) / np.pi)}
`;

                await pyodide.runPythonAsync(pythonCode);
                console.log("Python code executed successfully");
                document.getElementById('loading').style.display = 'none';
                document.getElementById('main').style.display = 'block';

                document.getElementById("theta_a").addEventListener("input", updatePlot);
                document.getElementById("theta_b").addEventListener("input", updatePlot);
                document.getElementById("gamma").addEventListener("input", updatePlot);
                
                // Handle validation on both mouseup and touchend
                const attachValidationListeners = (sliderId) => {
                    const slider = document.getElementById(sliderId);
                    const validateOnRelease = () => {
                        if (!isValidPlot()) {
                            findValidValue(sliderId);
                        } else {
                            saveValidState();
                        }
                    };
                    slider.addEventListener("mouseup", validateOnRelease);
                    slider.addEventListener("touchend", validateOnRelease);
                };
                
                attachValidationListeners("theta_a");
                attachValidationListeners("theta_b");
                attachValidationListeners("gamma");
                
                // Also attach validation to portrait sliders
                attachValidationListeners("theta_a_p");
                attachValidationListeners("theta_b_p");
                attachValidationListeners("gamma_p");
                
                document.getElementById("regression").addEventListener("change", () => {
                    updatePlot();
                    updateExplanation();
                });
                document.getElementById("orthProj").addEventListener("change", () => {
                    updatePlot();
                    updateExplanation();
                });
                document.getElementById("chained").addEventListener("change", () => {
                    updatePlot();
                    updateExplanation();
                });
                document.getElementById("EVs").addEventListener("change", () => {
                    updatePlot();
                    updateExplanation();
                });
                
                // Add portrait container listeners (portrait sliders sync to landscape)
                document.getElementById("theta_a_p").addEventListener("input", () => {
                    document.getElementById("theta_a").value = document.getElementById("theta_a_p").value;
                    updatePlot();
                });
                document.getElementById("theta_b_p").addEventListener("input", () => {
                    document.getElementById("theta_b").value = document.getElementById("theta_b_p").value;
                    updatePlot();
                });
                document.getElementById("gamma_p").addEventListener("input", () => {
                    document.getElementById("gamma").value = document.getElementById("gamma_p").value;
                    updatePlot();
                });
                
                document.getElementById("regression_p").addEventListener("change", () => {
                    document.getElementById("regression").checked = document.getElementById("regression_p").checked;
                    updatePlot();
                    updateExplanation();
                });
                document.getElementById("orthProj_p").addEventListener("change", () => {
                    document.getElementById("orthProj").checked = document.getElementById("orthProj_p").checked;
                    updatePlot();
                    updateExplanation();
                });
                document.getElementById("chained_p").addEventListener("change", () => {
                    document.getElementById("chained").checked = document.getElementById("chained_p").checked;
                    updatePlot();
                    updateExplanation();
                });
                document.getElementById("EVs_p").addEventListener("change", () => {
                    document.getElementById("EVs").checked = document.getElementById("EVs_p").checked;
                    updatePlot();
                    updateExplanation();
                });

                console.log("Event listeners attached, calling updatePlot...");
                setupExpanderListeners();
                setupTouchTooltips();
                updatePlot();
                updateExplanation();
                saveValidState();
            } catch (error) {
                console.error("Error during initialization:", error);
                document.getElementById('loading').innerHTML = '<div style="color: red; padding: 20px;"><strong>Error:</strong> ' + error.message + '<br><br><pre style="text-align: left; background: #f0f0f0; padding: 10px;">' + error.stack + '</pre></div>';
            }
        }

        function updatePlot() {
            try {
                syncContainers();
                
                const theta_a = parseFloat(document.getElementById("theta_a").value);
                const theta_b = parseFloat(document.getElementById("theta_b").value);
                const gamma = parseFloat(document.getElementById("gamma").value);
                const regression = document.getElementById("regression").checked;
                const orthProj = document.getElementById("orthProj").checked;
                const chained = document.getElementById("chained").checked;
                const EVs = document.getElementById("EVs").checked;

                document.getElementById("val_theta_a").textContent = theta_a.toFixed(2);
                document.getElementById("val_theta_b").textContent = theta_b.toFixed(2);
                document.getElementById("val_gamma").textContent = gamma.toFixed(2);

                const result = pyodide.globals.get("plot_arrows_data")(theta_a, theta_b, gamma, regression, orthProj, chained, EVs);
                
                // Convert PyDict to JavaScript object
                const resultObj = {};
                for (const key of result.keys()) {
                    const val = result.get(key);
                    if (key === 'arrows') {
                        // Convert arrows list
                        resultObj[key] = [];
                        for (let i = 0; i < val.length; i++) {
                            const arrowPy = val.get(i);
                            resultObj[key].push({
                                x: arrowPy.get('x').toJs(),
                                y: arrowPy.get('y').toJs(),
                                color: arrowPy.get('color'),
                                name: arrowPy.get('name'),
                                width: arrowPy.get('width') || 3,
                                dash: arrowPy.get('dash') || 'solid',
                                opacity: arrowPy.get('opacity') || 1.0,
                                hovertemplate: arrowPy.get('hovertemplate') || null
                            });
                        }
                    } else if (key === 'contributions') {
                        // Convert contributions dict - it comes as a PyDict with 'circles' and 'dots' keys
                        const circles = [];
                        const dots = [];
                        
                        // Access PyDict via .get()
                        const circlesPy = val.get('circles');
                        const dotsPy = val.get('dots');
                        
                        if (circlesPy && circlesPy.length > 0) {
                            for (let i = 0; i < circlesPy.length; i++) {
                                const c = circlesPy.get(i);
                                const center = c.get('center');
                                const radius = c.get('radius');
                                const color = c.get('color');
                                const label = c.get('label');
                                
                                let centerArray = center;
                                if (center && typeof center.toJs === 'function') {
                                    centerArray = Array.from(center.toJs());
                                } else if (center && typeof center === 'object' && center.length !== undefined) {
                                    centerArray = Array.from(center);
                                }
                                
                                circles.push({
                                    center: centerArray,
                                    radius: typeof radius === 'number' ? radius : parseFloat(radius),
                                    color: color,
                                    label: label
                                });
                            }
                        }
                        if (dotsPy && dotsPy.length > 0) {
                            for (let i = 0; i < dotsPy.length; i++) {
                                const d = dotsPy.get(i);
                                const x = d.get('x');
                                const y = d.get('y');
                                const color = d.get('color');
                                const label = d.get('label');
                                
                                dots.push({
                                    x: typeof x === 'number' ? x : parseFloat(x),
                                    y: typeof y === 'number' ? y : parseFloat(y),
                                    color: color,
                                    label: label
                                });
                            }
                        }
                        resultObj[key] = { circles, dots };
                    } else {
                        resultObj[key] = val;
                    }
                }

                const traces = [];
                
                // Add arrow traces
                for (let i = 0; i < resultObj.arrows.length; i++) {
                    const arrow = resultObj.arrows[i];
                    const isDashed = arrow.dash === 'dash';
                    const traceObj = {
                        x: arrow.x,
                        y: arrow.y,
                        mode: 'lines+markers',
                        type: 'scatter',
                        name: isDashed || arrow.name === '' ? '' : arrow.name,
                        line: { color: arrow.color, width: arrow.width || 3, dash: arrow.dash || 'solid' },
                        marker: { size: 8 },
                        opacity: arrow.opacity,
                        showlegend: !isDashed && arrow.name !== ''
                    };
                    
                    // Add hovertemplate
                    if (arrow.hovertemplate) {
                        // Use custom hovertemplate if provided in Python
                        traceObj.hovertemplate = arrow.hovertemplate;
                    } else {
                        // Default: show coordinates with 2 decimal places for other arrows
                        traceObj.hovertemplate = 'x: %{x:.2f}<br>y: %{y:.2f}<extra></extra>';
                    }
                    
                    traces.push(traceObj);
                }
                
                // Add circles as scatter plots (circle outlines)
                if (EVs && resultObj.contributions && resultObj.contributions.circles) {
                    for (const circle of resultObj.contributions.circles) {
                        const theta = [];
                        const circleX = [];
                        const circleY = [];
                        for (let i = 0; i <= 100; i++) {
                            theta.push(2 * Math.PI * i / 100);
                            circleX.push(circle.center[0] + circle.radius * Math.cos(theta[i]));
                            circleY.push(circle.center[1] + circle.radius * Math.sin(theta[i]));
                        }
                        traces.push({
                            x: circleX,
                            y: circleY,
                            mode: 'lines',
                            type: 'scatter',
                            name: 'circle',
                            line: { color: circle.color, width: 1 },
                            opacity: 0.2,
                            showlegend: false,
                            hoverinfo: 'skip'
                        });
                    }
                }
                
                // Add dots
                if (EVs && resultObj.contributions && resultObj.contributions.dots) {
                    for (const dot of resultObj.contributions.dots) {
                        traces.push({
                            x: [dot.x],
                            y: [dot.y],
                            mode: 'markers',
                            type: 'scatter',
                            name: '',
                            marker: { color: dot.color, size: 8 },
                            showlegend: false,
                            hoverinfo: 'skip'
                        });
                    }
                }

                const layout = { 
                    title: '', 
                    xaxis: { range: [-1.2, 1.2], scaleanchor: 'y', scaleratio: 1 }, 
                    yaxis: { range: [-1.2, 1.2] }, 
                    height: 500,
                    margin: { l: 50, r: 30, t: 50, b: 30 },
                    legend: { x: 0.02, y: 0.98, font: { size: 14 } }
                };
                
                // Render to both plot containers
                Plotly.newPlot('plot', traces, layout, { responsive: true });
                Plotly.newPlot('plot-portrait', traces, layout, { responsive: true });

                // Update stats in both containers
                document.getElementById('stat_T').textContent = (resultObj.T * 100).toFixed(1);
                document.getElementById('stat_U').textContent = (resultObj.U * 100).toFixed(1);
                document.getElementById('stat_INT').textContent = (resultObj.INT * 100).toFixed(1);
                document.getElementById('stat_Ad').textContent = (resultObj.Ad * 100).toFixed(1);
                
                document.getElementById('stat_T_p').textContent = (resultObj.T * 100).toFixed(1);
                document.getElementById('stat_U_p').textContent = (resultObj.U * 100).toFixed(1);
                document.getElementById('stat_INT_p').textContent = (resultObj.INT * 100).toFixed(1);
                document.getElementById('stat_Ad_p').textContent = (resultObj.Ad * 100).toFixed(1);
                
                // Show/hide contribution dots based on EVs checkbox
                document.getElementById('dot_T').style.visibility = EVs ? 'visible' : 'hidden';
                document.getElementById('dot_U').style.visibility = EVs ? 'visible' : 'hidden';
                document.getElementById('dot_T_p').style.visibility = EVs ? 'visible' : 'hidden';
                document.getElementById('dot_U_p').style.visibility = EVs ? 'visible' : 'hidden';
            } catch (error) {
                console.error("Error in updatePlot:", error);
                console.error("Stack:", error.stack);
            }
        }

        window.addEventListener('load', initPython);
    </script>
</body>
</html>
